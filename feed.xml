<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://giovannibriglia.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://giovannibriglia.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-16T11:21:08+00:00</updated><id>https://giovannibriglia.github.io/feed.xml</id><title type="html">blank</title><subtitle>I am Robotics Engineer graduated at the University of Modena and Reggio Emilia (IT). From November &apos;24 I will be PhD student at the University of Pisa. My focus comprehends Causal Reinforcement Learning. </subtitle><entry><title type="html">Implement Causal Inference with pgmpy</title><link href="https://giovannibriglia.github.io/blog/2024/causal-inference-pgmpy/" rel="alternate" type="text/html" title="Implement Causal Inference with pgmpy"/><published>2024-08-13T00:00:00+00:00</published><updated>2024-08-13T00:00:00+00:00</updated><id>https://giovannibriglia.github.io/blog/2024/causal-inference-pgmpy</id><content type="html" xml:base="https://giovannibriglia.github.io/blog/2024/causal-inference-pgmpy/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="n">pgmpy.inference.CausalInference</span> <span class="kn">import</span> <span class="n">CausalInference</span>
<span class="kn">from</span> <span class="n">pgmpy.models.BayesianNetwork</span> <span class="kn">import</span> <span class="n">BayesianNetwork</span>
<span class="kn">from</span> <span class="n">pgmpy.estimators</span> <span class="kn">import</span> <span class="n">MaximumLikelihoodEstimator</span>
<span class="kn">import</span> <span class="n">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">import</span> <span class="n">itertools</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span>

<span class="k">class</span> <span class="nc">SingleCausalInference</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">causal_graph</span><span class="p">:</span> <span class="n">nx</span><span class="p">.</span><span class="n">DiGraph</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Initializes the SingleCausalInference class.

        Parameters:
        data (pd.DataFrame): The dataset to be used for causal inference.
        causal_graph (nx.DiGraph): A directed acyclic graph representing causal relationships.
        </span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">self</span><span class="p">.</span><span class="n">causal_graph</span> <span class="o">=</span> <span class="n">causal_graph</span>

        <span class="c1"># Create and fit the Bayesian Network model
</span>        <span class="n">self</span><span class="p">.</span><span class="n">bayesian_network</span> <span class="o">=</span> <span class="nc">BayesianNetwork</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">bayesian_network</span><span class="p">.</span><span class="nf">add_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">causal_graph</span><span class="p">.</span><span class="nf">edges</span><span class="p">())</span>
        <span class="n">self</span><span class="p">.</span><span class="n">bayesian_network</span><span class="p">.</span><span class="nf">fit</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">MaximumLikelihoodEstimator</span><span class="p">)</span>

        <span class="c1"># Ensure the model is valid
</span>        <span class="k">assert</span> <span class="n">self</span><span class="p">.</span><span class="n">bayesian_network</span><span class="p">.</span><span class="nf">check_model</span><span class="p">()</span>

        <span class="c1"># Initialize the Causal Inference object
</span>        <span class="n">self</span><span class="p">.</span><span class="n">causal_inference</span> <span class="o">=</span> <span class="nc">CausalInference</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bayesian_network</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_bayesian_network</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BayesianNetwork</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Returns the fitted Bayesian Network.

        Returns:
        BayesianNetwork: The fitted Bayesian Network.
        </span><span class="sh">"""</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">bayesian_network</span>

    <span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">interventions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">target_variable</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
              <span class="n">evidence</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">adjustment_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Perform causal inference to determine the effect of interventions on the target variable.

        Parameters:
        interventions (Dict[str, Any]): A dictionary of interventions (do-operations) on variables.
        target_variable (str): The variable of interest to query.
        evidence (Optional[Dict[str, Any]]): Observed evidence (optional).
        adjustment_set (Optional[set]): A set of variables for adjustment (optional).

        Returns:
        Dict[str, float]: The probability distribution of the target variable after intervention.
        </span><span class="sh">"""</span>
        <span class="c1"># Filter out the target variable from interventions to prevent conflicts
</span>        <span class="n">clean_interventions</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">interventions</span><span class="p">.</span><span class="nf">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">var</span> <span class="o">!=</span> <span class="n">target_variable</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">adjustment_set</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># If no adjustment set is provided, compute one automatically
</span>            <span class="n">intervention_vars</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">clean_interventions</span><span class="p">.</span><span class="nf">keys</span><span class="p">())</span>
            <span class="n">adjustment_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">itertools</span><span class="p">.</span><span class="nf">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">causal_graph</span><span class="p">.</span><span class="nf">predecessors</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">intervention_vars</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Ensure the target variable is not part of the adjustment set
</span>            <span class="n">adjustment_set</span><span class="p">.</span><span class="nf">discard</span><span class="p">(</span><span class="n">target_variable</span><span class="p">)</span>

        <span class="c1"># Perform the query with the provided or computed parameters
</span>        <span class="n">query_result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">causal_inference</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="n">target_variable</span><span class="p">],</span>
            <span class="n">do</span><span class="o">=</span><span class="n">clean_interventions</span><span class="p">,</span>
            <span class="n">evidence</span><span class="o">=</span><span class="n">clean_interventions</span> <span class="k">if</span> <span class="n">evidence</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">evidence</span><span class="p">,</span>
            <span class="n">adjustment_set</span><span class="o">=</span><span class="n">adjustment_set</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="bp">False</span>
        <span class="p">)</span>

        <span class="c1"># Convert the result (DiscreteFactor) to a dictionary format
</span>        <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nf">str</span><span class="p">(</span><span class="n">state</span><span class="p">):</span> <span class="nf">float</span><span class="p">(</span><span class="n">query_result</span><span class="p">.</span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">query_result</span><span class="p">.</span><span class="n">state_names</span><span class="p">[</span><span class="n">target_variable</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">result_dict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_for_nan_or_infinite</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Checks if the provided data contains NaN or infinite values.

        Parameters:
        data (Any): The data to check, can be a dict or set.

        Returns:
        bool: True if NaN or infinite values are found, False otherwise.
        </span><span class="sh">"""</span>
        <span class="k">def</span> <span class="nf">is_numeric</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="p">.</span><span class="nf">isinf</span><span class="p">(</span><span class="n">value</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span>
            <span class="nf">except </span><span class="p">(</span><span class="nb">ValueError</span><span class="p">,</span> <span class="nb">TypeError</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nf">is_numeric</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Warning: </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s"> contains NaN or infinite values.</span><span class="sh">"</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="nf">is_numeric</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Warning: Set contains NaN or infinite values: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Unsupported data type: </span><span class="si">{</span><span class="nf">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">validate_input_data</span><span class="p">(</span><span class="n">interventions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">evidence</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                            <span class="n">adjustment_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">set</span><span class="p">]):</span>
        <span class="sh">"""</span><span class="s">
        Validates input data to ensure it does not contain NaN or infinite values.

        Parameters:
        interventions (Dict[str, Any]): Interventions to be validated.
        evidence (Optional[Dict[str, Any]]): Evidence data to be validated.
        adjustment_set (Optional[set]): Adjustment set to be validated.

        Raises:
        ValueError: If NaN or infinite values are found in the data.
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="n">SingleCausalInference</span><span class="p">.</span><span class="nf">check_for_nan_or_infinite</span><span class="p">(</span><span class="n">interventions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Intervention data contains NaN or infinite values.</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">evidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">SingleCausalInference</span><span class="p">.</span><span class="nf">check_for_nan_or_infinite</span><span class="p">(</span><span class="n">evidence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Evidence data contains NaN or infinite values.</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">adjustment_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">SingleCausalInference</span><span class="p">.</span><span class="nf">check_for_nan_or_infinite</span><span class="p">(</span><span class="n">adjustment_set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Adjustment set data contains NaN or infinite values.</span><span class="sh">"</span><span class="p">)</span>

</code></pre></div></div> <p><a class="citation" href="#pearl2010causal">(Pearl, 2010)</a> miao</p>]]></content><author><name></name></author><category term="work"/><category term="concepts"/><summary type="html"><![CDATA[How to employ correctly causal inference in Python, what is causal inference and why you need it]]></summary></entry><entry><title type="html">Multithreading and Multiprocessing in Python</title><link href="https://giovannibriglia.github.io/blog/2024/multiprocessing-multithreading/" rel="alternate" type="text/html" title="Multithreading and Multiprocessing in Python"/><published>2024-08-13T00:00:00+00:00</published><updated>2024-08-13T00:00:00+00:00</updated><id>https://giovannibriglia.github.io/blog/2024/multiprocessing-multithreading</id><content type="html" xml:base="https://giovannibriglia.github.io/blog/2024/multiprocessing-multithreading/"><![CDATA[<p>Useful links:</p> <li> https://medium.com/capital-one-tech/python-guide-using-multiprocessing-versus-multithreading-55c4ea1788cd </li> <li> https://www.geeksforgeeks.org/difference-between-multithreading-vs-multiprocessing-in-python/ </li>]]></content><author><name></name></author><category term="work"/><category term="concepts"/><summary type="html"><![CDATA[When use one respect to other, best practices, possible implementations]]></summary></entry><entry><title type="html">Career Update</title><link href="https://giovannibriglia.github.io/blog/2024/resume-and-phd-announcement/" rel="alternate" type="text/html" title="Career Update"/><published>2024-07-31T00:00:00+00:00</published><updated>2024-07-31T00:00:00+00:00</updated><id>https://giovannibriglia.github.io/blog/2024/resume-and-phd-announcement</id><content type="html" xml:base="https://giovannibriglia.github.io/blog/2024/resume-and-phd-announcement/"><![CDATA[<p>In the past year (2023), after coming back from Munich, where I completed an incredible exchange semester through the Erasmus+ program, I decided, also thanks to this experience, to pursue a PhD. Consequently, I applied to Politecnico di Milano, the University of Modena and Reggio Emilia, and the Italian National PhD in AI (based at the University of Pisa).</p> <p>To my surprise, I was accepted by all three institutions.</p> <p>In October 2023, I graduated from the University of Modena and Reggio Emilia with a degree in Mechatronics, Robotics, and Automation Engineering, achieving a score of 110 with laude. Despite this success, I felt disoriented. My experience at TUM in Munich left me with the impression that the most interesting opportunities were abroad, making me doubt if Italy was the right place for me. As a result, I decided to decline the positions in Italy and apply for some PhD abroad. I was rejected without even getting an interview from the ETH-AI Center, Max Planck Institute for Intelligent Systems, Munich Center for Machine Learning, Cyber Valley, ELLIS, EPFL, BMW, and relAI. Moreover, I was rejected from the University of Delft, for which, at least, I got an interview. Nevertheless, I won a PhD position at Eindhoven University and at the KIT lab, but I refused both offers, I was not so excited.</p> <p>Mostly in February, when most evaluations came in, I felt quite low. It’s not always easy to brush off disappointments, and I felt a bit adrift.</p> <p>Fortunately, since November, I have been working with Stefano Mariani and Franco Zambonelli, who welcomed me warmly into their research group. Together, we are exploring the intersection and the integration of model-free and model-based approaches, particularly focusing on reinforcement learning and causality.</p> <p>Over time, I’ve come to realize that while your environment undoubtedly influences you, the people you work with have an even greater impact. With this understanding, I am excited to collaborate with them.</p> <p>Additionally, I was given the opportunity to attend in-person the OxML “Representation Learning and Generative AI” program at the University of Oxford.</p> <p>Regarding my efforts to secure a PhD abroad, I was unsuccessful. However, this experience made me much stronger and more convinced of my goals. I realized that a rejection does not define a person’s abilities, and there are SIGNIFICANT factors influencing such decisions.</p> <p>I think I have found my way and I am meeting incredible people. They are the ones who feed my hunger for knowledge.</p> <p>Now, I am delighted to have been accepted into the National PhD program in AI, ranking first among all participants. Starting in November, I will be a PhD student and will continue working with Stefano Mariani and Franco Zambonelli. Additionally, I am seeking an engaging visiting research period during my PhD journey… (oh no, here we go again).</p>]]></content><author><name></name></author><category term="work"/><category term="update"/><summary type="html"><![CDATA[What is happened so far and PhD announcement]]></summary></entry></feed>